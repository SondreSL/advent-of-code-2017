-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Advent of Code 2017
--   
--   Advent of Code 2017!
@package aoc2017
@version 0.1.0.0

module AOC2017.Types
type Challenge = String -> String
data C :: Type
[C] :: {cParse :: String -> Maybe a, cSolve :: a -> Maybe b, cShow :: b -> String} -> C
runC :: C -> Challenge
type ChallengeMap = Map (Finite 25) (Map Char Challenge)
data ChallengeSpec
CS :: Finite 25 -> Char -> ChallengeSpec
[_csDay] :: ChallengeSpec -> Finite 25
[_csPart] :: ChallengeSpec -> Char

module AOC2017.Discover

-- | Meant to be called like:
--   
--   <pre>
--   mkChallengeMap $$(challengeList "src<i>AOC2017</i>Challenge")
--   </pre>
mkChallengeMap :: [(Finite 25, (Char, Challenge))] -> ChallengeMap
challengeList :: FilePath -> Q (TExp [(Finite 25, (Char, Challenge))])

module AOC2017.Challenge.Day24
day24a :: Challenge
day24b :: Challenge

module AOC2017.Challenge.Day23
day23a :: Challenge
day23b :: Challenge
instance AOC2017.Challenge.Day23.HasProgState AOC2017.Challenge.Day23.ProgState

module AOC2017.Challenge.Day22
day22a :: Challenge
day22b :: Challenge
instance AOC2017.Challenge.Day22.HasSt AOC2017.Challenge.Day22.St
instance GHC.Enum.Enum AOC2017.Challenge.Day22.Dir
instance GHC.Classes.Eq AOC2017.Challenge.Day22.Flag
instance GHC.Base.Monoid AOC2017.Challenge.Day22.Dir

module AOC2017.Challenge.Day19
day19a :: Challenge
day19b :: Challenge

module AOC2017.Challenge.Day17
day17a :: Challenge
day17b :: Challenge

module AOC2017.Challenge.Day16
day16a :: Challenge
day16b :: Challenge
instance GHC.Show.Show a => GHC.Show.Show (AOC2017.Challenge.Day16.Perm a)
instance GHC.Classes.Ord a => Data.Semigroup.Semigroup (AOC2017.Challenge.Day16.Perm a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (AOC2017.Challenge.Day16.Perm a)

module AOC2017.Challenge.Day15
day15a :: Challenge
day15b :: Challenge

module AOC2017.Challenge.Day13
day13a :: Challenge
day13b :: Challenge

module AOC2017.Challenge.Day11
day11a :: Challenge
day11b :: Challenge

module AOC2017.Challenge.Day09
day09a :: Challenge
day09b :: Challenge

module AOC2017.Challenge.Day08
day08a :: Challenge
day08b :: Challenge

module AOC2017.Challenge.Day07
day07a :: Challenge
day07b :: Challenge

module AOC2017.Challenge.Day06
day06a :: Challenge
day06b :: Challenge

module AOC2017.Challenge.Day04
day04a :: Challenge
day04b :: Challenge

module AOC2017.Challenge.Day03
day03a :: Challenge
day03b :: Challenge
instance Data.Semigroup.Semigroup (AOC2017.Challenge.Day03.Trail a)
instance GHC.Base.Monoid (AOC2017.Challenge.Day03.Trail a)

module AOC2017.Challenge.Day02
day02a :: Challenge
day02b :: Challenge

module AOC2017.Challenge.Day01
day01a :: Challenge
day01b :: Challenge

module AOC2017.Util
strip :: String -> String
iterateMaybe :: (a -> Maybe a) -> a -> [a]

-- | Strict (!!)
(!!!) :: [a] -> Int -> a
dup :: a -> (a, a)
scanlT :: Traversable t => (b -> a -> b) -> b -> t a -> t b
scanrT :: Traversable t => (a -> b -> b) -> b -> t a -> t b

module AOC2017.Challenge.Day25
day25a :: Challenge
instance GHC.Show.Show AOC2017.Challenge.Day25.RuleSet

module AOC2017.Challenge.Day21
day21a :: Challenge
day21b :: Challenge

module AOC2017.Challenge.Day20
type Point = V3 Int
data Particle a
P :: !a -> !a -> !a -> Particle a
[_pAcc] :: Particle a -> !a
[_pVel] :: Particle a -> !a
[_pPos] :: Particle a -> !a
type System = [Particle Point]
step :: Num a => Particle a -> Particle a
collide :: System -> System
norm :: Point -> Int
day20a :: Challenge
day20b :: Challenge
parse :: String -> System
instance GHC.Classes.Ord a => GHC.Classes.Ord (AOC2017.Challenge.Day20.Particle a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (AOC2017.Challenge.Day20.Particle a)
instance GHC.Show.Show a => GHC.Show.Show (AOC2017.Challenge.Day20.Particle a)
instance Data.Traversable.Traversable AOC2017.Challenge.Day20.Particle
instance Data.Foldable.Foldable AOC2017.Challenge.Day20.Particle
instance GHC.Base.Functor AOC2017.Challenge.Day20.Particle

module AOC2017.Challenge.Day10
day10a :: Challenge
day10b :: Challenge
knothash :: String -> [Word8]

module AOC2017.Challenge.Day05
day05a :: Challenge
day05b :: Challenge

module AOC2017.Util.Accum
class (Monoid w, Monad m) => MonadAccum w m | m -> w
add :: MonadAccum w m => w -> m ()
look :: (MonadAccum w m, Monoid w) => m w

-- | An accumulation monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
--   
--   This monad transformer is similar to both state and writer monad
--   transformers. Thus it can be seen as
--   
--   <ul>
--   <li>a restricted append-only version of a state monad transformer
--   or</li>
--   <li>a writer monad transformer with the extra ability to read all
--   previous output.</li>
--   </ul>
newtype AccumT w (m :: * -> *) a :: * -> (* -> *) -> * -> *
AccumT :: (w -> m (a, w)) -> AccumT w a

-- | Extract the output from an accumulation computation.
--   
--   <ul>
--   <li><pre><a>execAccumT</a> m w = <a>liftM</a> <a>snd</a>
--   (<a>runAccumT</a> m w)</pre></li>
--   </ul>
execAccumT :: Monad m => AccumT w m a -> w -> m w

-- | Evaluate an accumulation computation with the given initial output
--   history and return the final value, discarding the final output.
--   
--   <ul>
--   <li><pre><a>evalAccumT</a> m w = <a>liftM</a> <a>fst</a>
--   (<a>runAccumT</a> m w)</pre></li>
--   </ul>
evalAccumT :: (Monad m, Monoid w) => AccumT w m a -> w -> m a

-- | An accumulation monad parameterized by the type <tt>w</tt> of output
--   to accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Accum w = AccumT w Identity

-- | Construct an accumulation computation from a (result, output) pair.
--   (The inverse of <a>runAccum</a>.)
accum :: Monad m => (w -> (a, w)) -> AccumT w m a

-- | Unwrap an accumulation computation as a (result, output) pair. (The
--   inverse of <a>accum</a>.)
runAccum :: () => Accum w a -> w -> (a, w)

-- | Extract the output from an accumulation computation.
--   
--   <ul>
--   <li><pre><a>execAccum</a> m w = <a>snd</a> (<a>runAccum</a> m
--   w)</pre></li>
--   </ul>
execAccum :: () => Accum w a -> w -> w

-- | Evaluate an accumulation computation with the given initial output
--   history and return the final value, discarding the final output.
--   
--   <ul>
--   <li><pre><a>evalAccum</a> m w = <a>fst</a> (<a>runAccum</a> m
--   w)</pre></li>
--   </ul>
evalAccum :: Monoid w => Accum w a -> w -> a
instance (GHC.Base.Monoid w, GHC.Base.Monad m) => AOC2017.Util.Accum.MonadAccum w (Control.Monad.Trans.Accum.AccumT w m)
instance AOC2017.Util.Accum.MonadAccum w m => AOC2017.Util.Accum.MonadAccum w (Control.Monad.Trans.Maybe.MaybeT m)
instance AOC2017.Util.Accum.MonadAccum w m => AOC2017.Util.Accum.MonadAccum w (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monoid a, GHC.Base.Monoid w, Control.Monad.Writer.Class.MonadWriter w m) => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Accum.AccumT a m)

module AOC2017.Challenge.Day18
day18a :: Challenge
day18b :: Challenge
instance AOC2017.Challenge.Day18.HasThread AOC2017.Challenge.Day18.Thread
instance AOC2017.Challenge.Day18.HasProgState AOC2017.Challenge.Day18.Thread
instance AOC2017.Challenge.Day18.HasProgState AOC2017.Challenge.Day18.ProgState

module AOC2017.Util.Disjoints

-- | Monoid representing a collection of disjoint "connected sets"
newtype Disjoints
D :: Set IntSet -> Disjoints
[getD] :: Disjoints -> Set IntSet
disjoint :: IntSet -> Disjoints
instance GHC.Base.Monoid AOC2017.Util.Disjoints.Disjoints

module AOC2017.Challenge.Day14
day14a :: Challenge
day14b :: Challenge

module AOC2017.Challenge.Day12
day12a :: Challenge
day12b :: Challenge

module AOC2017
challengeMap :: Map (Finite 25) (Map Char Challenge)
data ChallengePaths
CP :: !FilePath -> !FilePath -> !FilePath -> !FilePath -> !FilePath -> !FilePath -> ChallengePaths
[_cpDataUrl] :: ChallengePaths -> !FilePath
[_cpPromptUrl] :: ChallengePaths -> !FilePath
[_cpInput] :: ChallengePaths -> !FilePath
[_cpAnswer] :: ChallengePaths -> !FilePath
[_cpPrompt] :: ChallengePaths -> !FilePath
[_cpTests] :: ChallengePaths -> !FilePath
challengePaths :: ChallengeSpec -> ChallengePaths
data ChallengeData
CD :: !(Either [String] String) -> !(Maybe String) -> ![(String, Maybe String)] -> !(Either [String] String) -> ChallengeData
[_cdInp] :: ChallengeData -> !(Either [String] String)
[_cdAns] :: ChallengeData -> !(Maybe String)
[_cdTests] :: ChallengeData -> ![(String, Maybe String)]
[_cdPrompt] :: ChallengeData -> !(Either [String] String)
challengeData :: Maybe String -> ChallengeSpec -> IO ChallengeData
data Config
Cfg :: Maybe String -> Config
[_cfgSession] :: Config -> Maybe String
configFile :: FilePath -> IO Config
defConfPath :: FilePath
session :: FilePath -> IO (Maybe String)
instance GHC.Generics.Generic AOC2017.Config
instance GHC.Show.Show AOC2017.ChallengePaths
instance Data.Aeson.Types.ToJSON.ToJSON AOC2017.Config
instance Data.Aeson.Types.FromJSON.FromJSON AOC2017.Config
