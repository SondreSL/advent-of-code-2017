{-# LANGUAGE RankNTypes #-}

module AOC2017.Day21 (day21a, day21b) where

import           AOC2017.Types   (Challenge)
import           AOC2017.Util    ((!!!), strip)
import           Control.Lens    (over, Traversal')
import           Data.List       (transpose)
import           Data.List.Split (chunksOf, splitOn)
import qualified Data.Map        as M

type Grid = [[Bool]]

type Rule = M.Map Grid Grid

-- | All 8 symmetries (elements of D8)
--
-- Generated by r, r^2, r^3, r^4, and flip times all of those
symmetries :: Grid -> [Grid]
symmetries g = rots ++ (mirror <$> rots)
  where
    -- all rotations
    rots = take 4 (iterate rot90 g)
    -- rotate 90 degrees
    rot90 = map reverse . transpose
    -- flip
    mirror = reverse

parse :: String -> Rule
parse = M.unions . map (M.fromList . parseLine) . lines
  where
    parseLine :: String -> [(Grid, Grid)]
    parseLine (map(splitOn "/".strip).splitOn"=>"->[xs,ys]) =
          [ (g, gridOut) | g <- symmetries gridIn ]
      where
        gridIn  = fmap (== '#') <$> xs
        gridOut = fmap (== '#') <$> ys
    parseLine _ = error "No parse"

-- | A traversal over subgrids of a grid
subgrids :: Int -> Traversal' Grid Grid
subgrids n f = fmap joinGrid . (traverse . traverse) f . splitGrid
  where
    splitGrid :: Grid -> [[Grid]]
    splitGrid = transpose
              . map (map transpose . chunksOf n . transpose)
              . chunksOf n
    joinGrid :: [[Grid]] -> Grid
    joinGrid = transpose . concatMap (transpose . concat)

step :: Rule -> Grid -> Grid
step r g = over (subgrids n) (r M.!) g
  where
    n | length g `mod` 2 == 0 = 2
      | length g `mod` 3 == 0 = 3
      | otherwise             = error "hello there"

grid0 :: Grid
grid0 = map (== '#') <$> [".#.","..#","###"]

day21 :: Int -> Rule -> Int
day21 n r = length . filter id . concat
          $ iterate (step r) grid0 !!! n

day21a :: Challenge
day21a = show . day21 5 . parse

day21b :: Challenge
day21b = show . day21 18 . parse
